<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <img src="https://cdn.apifox.com/app/project-icon/builtin/7.jpg" alt="">
    <img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.AV53EMWCZoYJR5tkVRc9vgHaEK?w=281&h=180&c=7&r=0&o=5&pid=1.7"
        alt="">
    <!-- <img src="https://static.vecteezy.com/ti/vetor-gratis/p3/641253-fundo-do-espaco-com-planetts-se-movendo-ao-redor-do-sol-em-orbitas-gratis-vetor.jpg"
        alt=""> -->
    <script>

        const LCP_SUB_PARTS = [
            'Time to first byte',
            'Resource load delay',
            'Resource load time',
            'Element render delay',
        ];

        new PerformanceObserver((list) => {
            console.log("list.getEntries():", list.getEntries(), performance.getEntriesByType('navigation'))
            const lcpEntry = list.getEntries().at(-1);
            const navEntry = performance.getEntriesByType('navigation')[0];
            const lcpResEntry = performance
                .getEntriesByType('resource')
                .filter((e) => e.name === lcpEntry.url)[0];


            // Compute the start and end times of each LCP sub-part.
            // WARNING! If your LCP resource is loaded cross-origin, make sure to add
            // the `Timing-Allow-Origin` (TAO) header to get the most accurate results.
            const ttfb = navEntry.responseStart;

            // 拿着response start 和  PerformanceResourceTiming
            const lcpRequestStart = Math.max(
                ttfb,
                // Prefer `requestStart` (if TOA is set), otherwise use `startTime`.
                lcpResEntry ? lcpResEntry.requestStart || lcpResEntry.startTime : 0
            );
            // 响应结束
            const lcpResponseEnd = Math.max(
                lcpResEntry ? lcpResEntry.responseEnd : 0
            );
            // PerformanceResourceTiming 渲染结束 responseEnd 
            // LargestContentfulPaint 的 startTime 

            const lcpRenderTime = Math.max(
                lcpResponseEnd,
                // Use LCP startTime (the final LCP time) because there are sometimes
                // slight differences between loadTime/renderTime and startTime
                // due to rounding precision.
                lcpEntry ? lcpEntry.startTime : 0
            );
            console.log("lcpResponseEnd渲染总时间:",
                {
                    lcpRenderTime, lcpEntry, lcpResEntry,
                    "lcpResEntry.responseEnd": lcpResEntry.responseEnd,
                    "lcpEntry.startTime": lcpEntry.startTime
                })
            // Clear previous measures before making new ones.
            // Note: due to a bug, this doesn't work in Chrome DevTools.
            LCP_SUB_PARTS.forEach((part) => performance.clearMeasures(part));

            const lcpSubPartMeasures = [
                // fp 的 时间
                performance.measure(LCP_SUB_PARTS[0], {
                    start: 0,
                    end: ttfb,
                }),
                // 资源加载的延迟
                performance.measure(LCP_SUB_PARTS[1], {
                    start: ttfb,
                    end: lcpRequestStart,
                }),
                // 资源加载完成的时间
                performance.measure(LCP_SUB_PARTS[2], {
                    start: lcpRequestStart,
                    end: lcpResponseEnd,
                }),
                // 完成渲染的时间
                performance.measure(LCP_SUB_PARTS[3], {
                    start: lcpResponseEnd,
                    end: lcpRenderTime,
                }),
            ];

            // Log helpful debug information to the console.
            console.log('LCP value: ', lcpRenderTime);
            console.log('LCP element: ', lcpEntry.element, lcpEntry.url);
            console.table(
                lcpSubPartMeasures.map((measure) => {
                    console.log("me", measure);
                    return {
                        'LCP sub-part': measure.name,
                        'Time (ms)': measure.duration,
                        '% of LCP': `${Math.round((1000 * measure.duration) / lcpRenderTime) / 10
                            }%`,
                    }
                })
            );
        }).observe({ type: 'largest-contentful-paint', buffered: true });
    </script>
</body>

</html>